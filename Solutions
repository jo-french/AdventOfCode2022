# Q1
import pandas as pd
import numpy as np0

with open('input.txt') as f:
    lines = f.read()

lines = lines.strip()
elves = lines.split("\n\n")

elfcalorylists = [elflist.split('\n') for elflist in elves]
intelfcalorylists = [[int(x) for x in elist] for elist in elfcalorylists]
elfcalories = [np.sum(elflist) for elflist in intelfcalorylists]

np.max(elfcalories)

sortedlist = elfcalories

sortedlist.sort(reverse=True)

np.sum(sortedlist[0:3])
sortedlist[0]+sortedlist[1]+sortedlist[2]

# Q2

import pandas as pd
import numpy as np

data = pd.read_csv('input.txt', sep = ' ', index_col=None, header=None)
data.set_axis(['Them', 'Me'], axis=1, inplace=True)

# Calculate win, lose, or draw
# A = Rock, B = Paper, C = Scissors
df = data

df = df.replace('A', 1)
df = df.replace('B', 2)
df = df.replace('C', 3)
df = df.replace('X', 1)
df = df.replace('Y', 2)
df = df.replace('Z', 3)

df['diff'] = df['Me'] - df['Them']
df = df.replace(-2, 1)
df = df.replace(-1, 2)

def score(val):
    if val == 0:
        return 3
    elif val == 1:
        return 6
    elif val == 2:
        return 0
    
df['winlosescore'] = df['diff'].apply(score)
df['totalscore'] = df['Me'] + df['winlosescore']

df['totalscore'].sum()

# X means you need to lose, Y means you need to end the round in a draw, and Z means you need to win.

def mynewmove(row):
    if row['Me'] == 1:
        return row['Them'] - 1
    elif row['Me'] == 2:
        return row['Them']
    elif row['Me'] == 3:
        return row['Them'] + 1
    
df['MyNewMove'] = df.apply (lambda row: mynewmove(row), axis=1)

df = df.replace(0, 3)
df = df.replace(4, 1)

df['newdiff'] = df['MyNewMove'] - df['Them']
df = df.replace(-2, 1)
df = df.replace(-1, 2)
df['newwinlosescore'] = df['newdiff'].apply(score)

df['newtotalscore'] = df['MyNewMove'] + df['newwinlosescore']
df['newtotalscore'].sum()

# Q3

import pandas as pd
import numpy as np

ord('a')
ord('A')
ord('Z') - ord('A') + 27
ord('b')
ord('b') - ord('a') + 1

# Convert lc letter to number by ord(letter) - ord('a') + 1
# Convert uc letter to number by ord(letter) - ord('A') + 27

with open('input.txt') as f:
    lines = f.read()

lines = lines.strip()
backpacks = lines.split('\n')

lengths = [len(s) for s in backpacks]
mids = [int(l/2) for l in lengths]

part1s = [backpacks[i][0:mids[i]] for i in range(len(backpacks))]
part2s = [backpacks[i][mids[i]:] for i in range(len(backpacks))]

intersections = [set(part1s[i]).intersection(set(part2s[i])) for i in range(len(backpacks))]
answers = [list(tVal) for tVal in intersections]
answers = [a[0] for a in answers]

def getPriority(letter):
    if letter.isupper():
        return ord(letter) - ord('A') + 27
    else:
        return ord(letter) - ord('a') + 1
    
priorities = [getPriority(l) for l in answers]
total = sum(priorities)

# Part2
elfgroups = []
for i in range(100):
    elfgroups.append(set(backpacks[3*i]).intersection(set(backpacks[3*i+1]), set(backpacks[3*i+2])))

eganswers = [list(tVal) for tVal in elfgroups]
eganswers = [a[0] for a in eganswers]

egpriorities = [getPriority(egl) for egl in eganswers]
egtotal = sum(egpriorities)

Q4

import pandas as pd
import numpy as np

with open('input.txt') as f:
    lines = f.read()

lines = lines.strip()

elves = lines.split('\n')
elves1 = [e.split(',')[0] for e in elves]
elves2 = [e.split(',')[1] for e in elves]

e11 = [int(e.split('-')[0]) for e in elves1]
e12 = [int(e.split('-')[1]) for e in elves1]

e21 = [int(e.split('-')[0]) for e in elves2]
e22 = [int(e.split('-')[1]) for e in elves2]

combined = list(zip(e11, e12, e21, e22))

def elfrcontainselfr(r):
    if (r[0] <= r[2] and r[3] <= r[1]):
        return 1
    elif (r[2] <= r[0] and r[1] <= r[3]):
        return 1
    else:
        return 0
    
containments = [elfrcontainselfr(r) for r in combined]
sum(containments)

def overlap(r):
    if (r[0] >= r[2] and r[0] <= r[3]):
        return 1
    elif (r[2] >= r[0] and r[2] <= r[1]):
        return 1
    else:
        return 0

overlapping = [overlap(r) for r in combined]

sum(overlapping)

# Q5

import pandas as pd
import numpy as np

with open('input.txt') as f:
    lines = f.read()

# Set up crates and instructions

lines = lines.strip()

cratearea = lines.split('\n\n')[0]

instructions = (lines.split('\n\n')[1]).split('\n')

# Column numbers:

# 1: 1
# 2: 5
# 3: 9
# n + 1: 4n + 1

cratelines = cratearea.split('\n')
cratelines[0] = '                ' + cratelines[0]

crates = []
for crate_i in range(9):
    crate_string = ''
    for j in range(8):
        if len(cratelines[j])>=4*crate_i+1:
            if cratelines[j][4*crate_i+1] != ' ':
                crate_string = crate_string+(cratelines[j][4*crate_i+1])
    crates.append(crate_string)
                
crates = [c[::-1] for c in crates]

# Rearrange crates
n_move = [int(a.split('move ')[1].split(' from')[0]) for a in instructions]
move_from = [int(a.split('from ')[1].split(' to')[0]) for a in instructions]
move_to = [int(a.split('to ')[1]) for a in instructions]

# Part 1

for i in range(len(instructions)):
    print(i)
    c1 = move_from[i] - 1
    c2 = move_to[i] - 1
    startn = len(crates[c1])-n_move[i]
    crates[c2] = crates[c2] + (crates[c1][startn:])[::-1]
    crates[c1] = crates[c1][:startn]

finalstring = ''
for i in range(len(crates)):
    finalstring = finalstring + crates[i][len(crates[i])-1]

finalstring        

# Part 2
# Reset crates
# Move the crates without reversing the order

for i in range(len(instructions)):
    print(i)
    c1 = move_from[i] - 1
    c2 = move_to[i] - 1
    startn = len(crates[c1])-n_move[i]
    crates[c2] = crates[c2] + (crates[c1][startn:])
    crates[c1] = crates[c1][:startn]
    
finalstring = ''
for i in range(len(crates)):
    finalstring = finalstring + crates[i][len(crates[i])-1]

finalstring

# Q6

import pandas as pd
import numpy as np

with open('input.txt') as f:
    lines = f.read()
    
import collections

maxidx = 3
thisfour = collections.deque(lines[0:4])

print(thisfour)

while len(set(thisfour)) < 4:
    print(maxidx)
    maxidx = maxidx + 1
    thisfour.popleft()
    thisfour.append(lines[maxidx])
    
print(maxidx + 1)

# Part 2
# Change to 14 characters

maxidx = 13
thisfourteen = collections.deque(lines[0:14])

print(thisfourteen)

while len(set(thisfourteen)) < 14:
    print(maxidx)
    maxidx = maxidx + 1
    thisfourteen.popleft()
    thisfourteen.append(lines[maxidx])
    
print(maxidx + 1)

# Q7

import pandas as pd
import numpy as np

with open('input.txt') as f:
    lines = f.read()
    
lines = lines.strip()
    
class directory:
    def __init__(self, name, previousdir):
        self.name = name
        self.subdirectories = set()
        self.files = set()
        self.prevdir = previousdir
    def add_file(self, file):
        self.files.add(file)
    def add_subdirectory(self, subdirectory):
        self.subdirectories.add(subdirectory)
        
class file:
    def __init__(self, filename, size, currentdir):
        self.filename = filename
        self.size = size
        self.currentdir = currentdir
        
        
home = directory("/", None)

commands = lines.split('\n')

alldirs = set()
alldirs.add('/')
dirdict = {}
filedict = {}

codeset = set()

thisdir = home

def process_file(currentdir, line):
    if len(line.split('dir')) > 1:
        subdirname = line.split('dir')[1].strip()
        if not subdirname + '-sub-' + currentdir.name in alldirs:
            subdir = directory(subdirname + '-sub-' + currentdir.name, currentdir)
            alldirs.add(subdirname + '-sub-' + currentdir.name)
            dirdict[subdirname + '-sub-' + currentdir.name] = subdir
        else:
            subdir = dirdict[subdirname + '-sub-' + currentdir.name]
        currentdir.add_subdirectory(subdir)          
    elif line[0].isdigit():
        newfilename = line.split(' ')[1]
        newfilesize = int(line.split(' ')[0])
        if not newfilename + '-in-' + currentdir.name in filedict:
            newfile = file(newfilename+ '-in-' + currentdir.name, newfilesize, currentdir)
            currentdir.add_file(newfile)
            filedict[newfilename+ '-in-' + currentdir.name] = newfile
        else:
            currentdir.add_file(filedict[newfilename+ '-in-' + currentdir.name])
        
def read_line(thisdir, lines, i):
    try:
        if i >= len(commands):
            return
        if lines[i].startswith('$ cd'):
            if lines[i].split('$ cd ')[1] == '..':
                if not thisdir.name == '/':
                    thisdir = thisdir.prevdir
            else:
                newdirname = lines[i].split('$ cd ')[1]
                if not newdirname + '-sub-' + thisdir.name in dirdict:
                    newdir = directory(newdirname + '-sub-' + thisdir.name, thisdir)
                    # Do we need to add newdir to currentdir?
                    alldirs.add(newdirname + '-sub-' + thisdir.name)
                    dirdict[newdirname + '-sub-' + thisdir.name] = newdir
                thisdir = dirdict[newdirname + '-sub-' + thisdir.name]
            i = i+1
        elif lines[i].startswith('$ ls'):
            if thisdir.name == 'bdnc':
                print(i)
                print(lines[i])
            i = i+1
            if i == len(commands):
                return
            while not lines[i].startswith('$') and i < len(commands):
                if thisdir.name == 'bdnc':
                    print(lines[i])
                    print('Here')
                process_file(thisdir, lines[i])
                i = i+1
        read_line(thisdir, commands, i)
    except:
        print(i)
        print(thisdir.name)
i = 0
read_line(thisdir, commands, i)

def calculatedirsize(mydir):
    size = 0
    for file in mydir.files:
        size = size + file.size
    for subdir in mydir.subdirectories:
        print(subdir.name)
        runonnames.append(subdir.name)
        size = size + calculatedirsize(subdir)
    return size
    
dirsizedict = {}
runon = []
runonnames = []
for dirname in dirdict:
    runon.append(dirname)
    dirsizedict[dirname] = calculatedirsize(dirdict[dirname])
    
sizemax = 100000

smalldirs = [d for d in dirsizedict if dirsizedict[d] <= sizemax]

smalldirsizesum = sum(dirsizedict[d] for d in smalldirs)

smallsizedir = {}
for d in smalldirs:
    smallsizedir[d] = dirsizedict[d]

# Part 2
    
totalspace = 70000000

spaceneeded = 30000000

totalusedspace = dirsizedict['/-sub-/']

freespace = totalspace - totalusedspace

spacetofree = spaceneeded - freespace

largeenoughdirs = [d for d in dirsizedict if dirsizedict[d] >= spacetofree]

largeenoughdirdict = {d: dirsizedict[d] for d in largeenoughdirs}

minsizedir = min(largeenoughdirdict, key=largeenoughdirdict.get)

largeenoughdirdict[minsizedir]

# Q8

import pandas as pd
import numpy as np

with open('input.txt') as f:
    lines = f.read()

lines = lines.strip()    
lines = lines.split('\n')

lines = [list(l) for l in lines]

df = np.array(lines)

ntrees = 99*99

treelist = []

def checktreevisible(data, i, j):
    treeheight = data[i, j]
    isvisible = 0
    v1 = 0
    v2 = 0
    v3 = 0
    v4 = 0
    for k in range(99):
        if data[k, j] >= data[i, j]:
            if k < i:
                v1 = 1
            if k > i:
                v2 = 1
        if data[i, k] >= data[i, j]:
            if k < j:
                v3 = 1
            if k > j:
                v4 = 1
    if v1 == 0 or v2 == 0 or v3 == 0 or v4 == 0:
        return 1
    else:
        return 0
    

for i in range(99):
    for j in range(99):
        treelist.append(checktreevisible(df, i, j))

sum(treelist)

#Part 2


def countnumberseen(l, h):
    nseen = 0
    for a in l:
        if a < h:
            nseen = nseen + 1
        if a >= h:
            nseen = nseen + 1
            break
    return nseen

def countvisibletrees(data, i, j):
    height = int(data[i, j])
    treesabove = [int(data[k, j]) for k in range(99) if k < i]
    treesabove.reverse()
    n1 = countnumberseen(treesabove, height)
    treesbelow = [int(data[k, j]) for k in range(99) if k > i]
    n2 = countnumberseen(treesbelow, height)
    treesleft = [int(data[i, k]) for k in range(99) if k < j]
    treesleft.reverse()
    n3 = countnumberseen(treesleft, height)
    treesright = [int(data[i, k]) for k in range(99) if k > j]
    n4 = countnumberseen(treesright, height)
    return n1 * n2 * n3 * n4

treelist1 = []

for i in range(99):
    for j in range(99):
        treelist1.append(countvisibletrees(df, i, j))

np.max(treelist1)        

# Q9

import pandas as pd
import numpy as np

with open('input.txt') as f:
    lines = f.read()
    
lines = lines.strip()
lines = lines.split('\n')

directions = [l.split(' ')[0] for l in lines]
vals = [int(l.split(' ')[1]) for l in lines]

start = [0, 0]
headpos = start
tailpos = start

headpositions = []
tailpositions = []
headpositions.append(headpos)
tailpositions.append(tailpos)

def updateposone(i, j, d):
    if d == 'U':
        i = i+1
    elif d == 'D':
        i = i-1
    elif d == 'R':
        j = j+1
    elif d == 'L':
        j = j-1
    return [i, j]

def moveH(headpos, tailpos, i, headpositions, tailpositions):
    dist = vals[i]
    direction = directions[i]
    for k in range(dist):
        headpos = updateposone(headpos[0], headpos[1], direction)
        headpositions.append(headpos)
        tailpos = updatetailposone(headpos, tailpos)
        tailpositions.append(tailpos)
    return headpos, tailpos
        
def updatetailposone(headpos, tailpos):
    h1 = headpos[0]
    h2 = headpos[1]
    t1 = tailpos[0]
    t2 = tailpos[1]
    if h1 == t1 and h2 == t2 + 2:
        return [t1, t2+1]
    elif h1 == t1 and h2 == t2-2:
        return [t1, t2-1]
    elif h2 == t2 and h1 == t1 + 2:
        return [t1+1, t2]
    elif h2 == t2 and h1 == t1 - 2:
        return [t1-1, t2]
    elif (h1 == t1 + 2 and h2 == t2 + 1) or (h1 == t1 + 1 and h2 == t2 + 2):
        return [t1 + 1, t2 + 1]
    elif (h1 == t1-2 and h2 == t2+1) or (h1 == t1-1 and h2==t2+2):
        return [t1-1, t2+1]
    elif (h1 == t1-2 and h2 == t2-1) or (h1 == t1-1 and h2 == t2-2):
        return [t1-1, t2-1]
    elif (h1 == t1 + 2 and h2 == t2-1) or (h1 == t1+1 and h2 == t2-2):
        return [t1+1, t2-1]
    else:
        return [t1, t2]
        
        
for i in range(len(directions)):
    headpos, tailpos = moveH(headpos, tailpos, i, headpositions, tailpositions)
    
setoftailpositions = set(tuple(x) for x in tailpositions)

len(setoftailpositions)


# Part 2

def updatetailposonenew(headpos, tailpos):
    h1 = headpos[0]
    h2 = headpos[1]
    t1 = tailpos[0]
    t2 = tailpos[1]
    if h1 == t1 and h2 == t2 + 2:
        return [t1, t2+1]
    elif h1 == t1 and h2 == t2-2:
        return [t1, t2-1]
    elif h2 == t2 and h1 == t1 + 2:
        return [t1+1, t2]
    elif h2 == t2 and h1 == t1 - 2:
        return [t1-1, t2]
    elif (h1 == t1 + 2 and h2 == t2 + 1) or (h1 == t1 + 1 and h2 == t2 + 2):
        return [t1 + 1, t2 + 1]
    elif (h1 == t1-2 and h2 == t2+1) or (h1 == t1-1 and h2==t2+2):
        return [t1-1, t2+1]
    elif (h1 == t1-2 and h2 == t2-1) or (h1 == t1-1 and h2 == t2-2):
        return [t1-1, t2-1]
    elif (h1 == t1 + 2 and h2 == t2-1) or (h1 == t1+1 and h2 == t2-2):
        return [t1+1, t2-1]
    elif (h1 == t1+2 and h2 == t2+2):
        return [t1+1, t2+1]
    elif (h1 == t1-2 and h2 == t2-2):
        return [t1-1, t2-1]
    elif (h1 == t1+2 and h2 == t2-2):
        return [t1+1, t2-1]
    elif (h1 == t1-2 and h2 == t2+2):
        return [t1-1, t2+1]
    else:
        return [t1, t2]
    
    
def moveHandTails(headpos, tailpositionlist, i, headpositions, tailpositions):
    dist = vals[i]
    direction = directions[i]
    for k in range(dist):
        headpos = updateposone(headpos[0], headpos[1], direction)
        headpositions.append(headpos)
        newtailpositionlist = []
        newtp = [0, 0]
        for i in range(len(tailpositionlist)):
            if i == 0:
                newtp = updatetailposonenew(headpos, tailpositionlist[0])
            else:
                print(newtailpositionlist[i-1], tailpositionlist[i])
                newtp = updatetailposonenew(newtailpositionlist[i-1], tailpositionlist[i])
            newtailpositionlist.append(newtp)
            print(newtailpositionlist)
        tailpositionlist = newtailpositionlist
        tailpositions.append(newtailpositionlist)
    return headpos, tailpositionlist



headpos = [0,0]
headpositions = []
tailpositions = []
tailpositionlist = []
for i in range(9):
    tailpositionlist.append([0,0])
    
for i in range(len(directions)):
    headpos, tailpositionlist = moveHandTails(headpos, tailpositionlist, i, headpositions, tailpositions)
    
setoftailpositions = set([tuple(x[8]) for x in tailpositions])

len(setoftailpositions)

# Q10

import pandas as pd
import numpy as np

with open('input.txt') as f:
    lines = f.read()
    
lines = lines.strip()
lines = lines.split('\n')

def processline(mincycles, Xs, currentcycle, currentX, i):
    if lines[i] == 'noop':
        mincycles.append(currentcycle+1)
        Xs.append(currentX)
    elif lines[i].startswith('addx'):
        numtoadd = int(lines[i].split('addx ')[1])
        mincycles.append(currentcycle+2)
        Xs.append(currentX + numtoadd)
        
mincycles = []
Xs = []
currentcycle = 0
currentX = 1
for i in range(len(lines)):
    processline(mincycles, Xs, currentcycle, currentX, i)
    currentcycle = mincycles[len(mincycles)-1]
    currentX = Xs[len(Xs)-1]
    
cyclesofinterest = [20, 60, 100, 140, 180, 220]
indicestouse = [max(i for i in range(len(Xs)) if mincycles[i] < j) for j in cyclesofinterest]

signalstrengths = [cyclesofinterest[i]*Xs[indicestouse[i]] for i in range(len(cyclesofinterest))]

sum(signalstrengths)

# Part 2

crt = np.zeros((6, 40))

cyclenum = 1
spritemid = 1
for j in range(6):
    for i in range(40):
        if cyclenum == 1:
            spritemid = 1
        else:
            maxindex = max(idx for idx in range(len(Xs)) if mincycles[idx] < cyclenum)
            spritemid = Xs[maxindex]
        if i in [spritemid - 1, spritemid, spritemid + 1]:
            crt[j, i] = 1
        cyclenum = cyclenum + 1

# Q11

import os

os.chdir('C:/Users/Jo/Documents/Advent_of_Code_2022/Q11')

import pandas as pd
import numpy as np

import math

with open('input.txt') as f:
    lines = f.read()
    
lines = lines.strip()
lines = lines.split('\n')

#nmonkeys = 4
nmonkeys = 8

items = [lines[1 + 7 * i].split('items: ')[1] for i in range(nmonkeys)]
items = [iteml.split(',') for iteml in items]
items = [[int(a.strip()) for a in iteml] for iteml in items]
inspected = [[] for i in range(len(items))]
true = [int(lines[4 + 7 * i].split('monkey ')[1]) for i in range(nmonkeys)]
false = [int(lines[5 + 7 * i].split('monkey ')[1]) for i in range(nmonkeys)]
testnum = [int(lines[3 + 7 * i].split('by ')[1]) for i in range(nmonkeys)]
print([lines[2 + 7 * i].split('= old ')[1] for i in range(nmonkeys)])
#opnum = [19, 6, 0, 3]
opnum = [3, 11, 6, 4, 8, 2, 0, 5] # 0 = old
# 1 = *, 2 = +
#opact = [1, 2, 1, 2]
opact = [1, 1, 2, 2, 2, 2, 1, 2]

def op(i, itnum, opnum, opact):
    iopact = opact[i]
    if opnum[i] == 0:
        opn = itnum
    else:
        opn = opnum[i]
    if iopact == 1:
        return itnum * opn
    else:
        return itnum + opn
    
def opmod(i, itnum, opnum, opact, modnum, maxmult):
    iopact = opact[i]
    if opnum[i] == 0:
        opn = itnum
    else:
        opn = opnum[i]
    if iopact == 1:
        if opnum[i] == 0:
            return factormult(itnum, modnum, maxmult)
        else:
            return itnum * opn
    else:
        return itnum + opn
    
def factorise(n):
    currentn = n
    currentnfactors = []
    sqrtn = math.trunc(np.sqrt(currentn))
    for i in range(sqrtn + 1):
        if i > 1:
            if currentn % i == 0:
                currentnfactors.append(i)
                currentn = int(currentn / i)
                otherfactors = factorise(currentn)
                currentnfactors = currentnfactors + otherfactors
                break
    if len(currentnfactors) == 0:
        currentnfactors = [n]
    return currentnfactors

def multsum(thisnum, j, modnum, maxmult):
    divisor = math.trunc(j / maxmult)
    remainder = j - divisor * maxmult
    newnum = 0
    for k in range(divisor):
        tempnum = thisnum * maxmult
        tempnum = tempnum % modnum
        newnum = newnum + tempnum
        newnum = newnum % modnum   
    remnum = thisnum * remainder
    remnum = remnum % modnum
    newnum = newnum + remnum
    newnum = newnum % modnum
    return newnum
    
def factormult(itnum, modnum, maxmult):
    factorsnum = []
    factorsnum = factorise(itnum)
    newnum = itnum
    for j in factorsnum:
        if j > maxmult:
            newnum = multsum(newnum, j, modnum, maxmult)
        else:
            newnum = newnum * j
        newnum = newnum % modnum
    return newnum
         
def monkeyturn(i, items, opnum, opact, inspected, modnum = None, divide3 = True, usefactormult = False, maxmult = 200):
    monkeyitems = items[i]
    inspectedi = len(monkeyitems)
    inspected[i].append(inspectedi)
    for itnum in monkeyitems:
        if usefactormult:
            itnum = opmod(i, itnum, opnum, opact, modnum, maxmult)
        else:
            itnum = op(i, itnum, opnum, opact)
        if divide3:
            itnum = math.trunc(itnum / 3)
        if not modnum == None:
            itnum = itnum % modnum
        if itnum % testnum[i] == 0:
            items[true[i]].append(itnum)
        else:
            items[false[i]].append(itnum)
    items[i] = []
    
# Part 1
    
for j in range(20):
     for i in range(len(items)):
         monkeyturn(i, items, opnum, opact, inspected)
        
res = [sum(insp) for insp in inspected]

sortedres = sorted(res)
answer = sortedres[6]*sortedres[7]

# Part 2

# Reload data

modnum = np.prod(testnum)

for j in range(10000):
    for i in range(len(items)):
        monkeyturn(i, items, opnum, opact, inspected, modnum, False, True)
        
res = [sum(insp) for insp in inspected]

sortedres = sorted(res)
answer = sortedres[6]*sortedres[7]
